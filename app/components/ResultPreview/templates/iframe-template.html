<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AI Generated App</title>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/html2canvas-pro@1.5.8/dist/html2canvas-pro.js"></script>
    <!-- html2canvas-pro handles modern CSS color formats like OKLCH natively -->
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family:
          -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      }
      #container {
        width: 100%;
        height: 100vh;
      }
    </style>
    <script>
      const activeRequests = new Set();
      let lastState = null;

      function updateStreamingState() {
        const currentState = activeRequests.size > 0;
        if (currentState !== lastState) {
          lastState = currentState;
          window.parent.postMessage({ type: 'streaming', state: currentState }, '*');
        }
      }

      const originalFetch = window.fetch;
      window.fetch = (...args) => {
        const reqInfo = args[0];
        activeRequests.add(reqInfo);
        updateStreamingState();

        return originalFetch(...args).then((res) => {
          if (!res.body) {
            activeRequests.delete(reqInfo);
            updateStreamingState();
            return res;
          }
          const reader = res.body.getReader();
          const stream = new ReadableStream({
            start(controller) {
              function pump() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    activeRequests.delete(reqInfo);
                    updateStreamingState();
                    controller.close();
                    return;
                  }
                  controller.enqueue(value);
                  pump();
                });
              }
              pump();
            },
          });
          return new Response(stream, { headers: res.headers });
        });
      };

      // Screenshot functionality
      function captureScreenshot() {
        // Check if html2canvas is loaded
        if (typeof html2canvas === 'undefined') {
          console.warn('html2canvas-pro is not loaded, trying to load it dynamically');
          // Try to load html2canvas-pro dynamically
          const script = document.createElement('script');
          script.src = 'https://unpkg.com/html2canvas-pro@1.5.8/dist/html2canvas-pro.js';
          script.onload = () => {
            captureScreenshotWithFallback();
          };
          script.onerror = (e) => {
            window.parent.postMessage(
              { type: 'screenshot-error', error: 'Failed to load html2canvas' },
              '*'
            );
          };
          document.head.appendChild(script);
          return;
        }

        captureScreenshotWithFallback();
      }

      function captureScreenshotWithFallback() {
        try {
          // Let html2canvas-pro do its job with modern CSS
          html2canvas(document.body, {
            allowTaint: true,
            useCORS: true,
            scale: 1,
            logging: false,
          })
            .then((canvas) => {
              const dataURI = canvas.toDataURL();
              window.parent.postMessage({ type: 'screenshot', data: dataURI }, '*');
            })
            .catch((err) => {
              console.error('html2canvas-pro error:', err);
              window.parent.postMessage(
                {
                  type: 'screenshot-error',
                  error: 'Screenshot capture failed: ' + (err.message || 'Unknown error'),
                },
                '*'
              );
            });
        } catch (err) {
          console.error('Unexpected html2canvas-pro error:', err);
          window.parent.postMessage(
            {
              type: 'screenshot-error',
              error: 'Unexpected error during screenshot capture',
            },
            '*'
          );
        }
      }

      function pageIsLoaded() {
        window.parent.postMessage({ type: 'preview-ready' }, '*');
        setTimeout(captureScreenshot, 2000);
      }

      // For rapid updates (optional)
      let currentApp = null;
      function updateAppComponent(code) {
        try {
          // Evaluate new component code
          eval(code);

          // If we implement rapid updates, we'll need to re-render here
          if (currentApp && window.ReactDOM) {
            // Re-render with new component
          }

          return true;
        } catch (error) {
          console.error('Failed to update component:', error);
          return false;
        }
      }

      // Event listeners
      window.addEventListener('message', function (event) {
        if (event.data) {
          if (event.data.type === 'command') {
            if (event.data.command === 'capture-screenshot') {
              captureScreenshot();
            }
          } else if (event.data.type === 'callai-api-key' && event.data.key) {
            window.CALLAI_API_KEY = event.data.key;
          }
        }
      });

      window.addEventListener('DOMContentLoaded', function () {
        pageIsLoaded();
      });
    </script>
  </head>
  <body>
    <div id="container"></div>
    <script>
      window.CALLAI_API_KEY = '{{API_KEY}}';
      window.SESSION_ID = '{{SESSION_ID}}';
    </script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19.1.0/es2022/react.mjs",
          "react-dom": "https://esm.sh/react-dom@19.1.0/es2022/react-dom.mjs",
          "react-dom/client": "https://esm.sh/react-dom@19.1.0/es2022/client.mjs",
          "use-fireproof": "https://esm.sh/use-fireproof@0.20.4",
          "call-ai": "https://esm.sh/call-ai@0.6.1",
          "three": "https://esm.sh/three"
        }
      }
    </script>

    <!-- IndexedDB hook to prefix database names with session ID -->
    <script>
      // Save the original indexedDB.open method
      const originalIndexedDBOpen = indexedDB.open;
      const sessionId = window.SESSION_ID || 'default-session';

      /*
       * Replace with our wrapped version - only for Fireproof databases, with exceptions
       * This namespacing follows the same pattern used in DatabaseData.tsx: fp.vx-[sessionId]-[originalName]
       * So a database named 'fp.ai-playlist-db' would become 'fp.vx-sessionId-ai-playlist-db'
       */
      indexedDB.open = function (name, ...args) {
        // Skip namespacing for non-Fireproof databases (must start with 'fp.').
        // NOTE: This also implicitly skips databases like 'fp-keybag' that use a hyphen.
        if (!name || !name.startsWith('fp.')) {
          return originalIndexedDBOpen.call(this, name, ...args);
        }

        // Skip namespacing for internal Vibes databases
        if (name.startsWith('fp.vibe-') || name.startsWith('fp.vibes-')) {
          return originalIndexedDBOpen.call(this, name, ...args);
        }

        // Skip if already namespaced (starts with v-) - handles namespacing from DataView/DatabaseData.tsx
        if (name.startsWith('v-')) {
          return originalIndexedDBOpen.call(this, name, ...args);
        }

        // Apply namespacing to all other Fireproof databases
        // IMPORTANT: This pattern must match what's used in DataView/DatabaseData.tsx
        // Insert the vx-sessionId into the database name instead of prefixing the whole name
        const dbNameWithoutPrefix = name.substring(3); // Remove 'fp.' prefix
        const namespacedName = 'fp.vx-' + sessionId + '-' + dbNameWithoutPrefix;
        return originalIndexedDBOpen.call(this, namespacedName, ...args);
      };
    </script>

    <script type="text/babel" data-type="module">
      import ReactDOMClient from 'react-dom/client';

      // App runs normally without our interference, but the iframe loads our script to modify use-fireproof
      // prettier-ignore
      {{APP_CODE}}
      // prettier-ignore-end

      const rootElement = document.getElementById('container');
      ReactDOMClient.createRoot(rootElement).render(<App />);
    </script>
  </body>
</html>
